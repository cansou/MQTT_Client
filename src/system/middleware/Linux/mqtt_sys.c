#include "mqtt_include.h"


mqttRespStatus  mqttSysInit( void )
{
    return  MQTT_RESP_OK ;
} // end of mqttSysInit


mqttRespStatus  mqttSysDeInit( void )
{
    return  MQTT_RESP_OK ;
} // end of mqttSysDeInit



mqttRespStatus  mqttSysNetconnStart( mqttCtx_t *mctx )
{
    if(mctx == NULL){ return MQTT_RESP_ERRARGS; }
    int    sockfd  = -1;
    int    status  = 0;
    struct sockaddr_in  serv_addr;
    // get broker hostname & port
    mqttAuthGetBrokerHost( &mctx->broker_host, &mctx->broker_port );
    XMEMSET( &serv_addr, 0x00, sizeof(serv_addr) );
    // check whether the given broker_host stores IP address or host name, or malformed char array.
    status = inet_pton(AF_INET, (const char *)&mctx->broker_host->data[0], &serv_addr.sin_addr);
    if(status == 1) { // success return value, the given broker_host stores IP address
        // create a socket that uses IPv4 address, set the socket to be stream based (TCP)
        // the second argument is set to zero, which means we use default value.
        sockfd = socket( AF_INET, SOCK_STREAM, 0 );
        if(sockfd == -1) { return  MQTT_RESP_NO_NET_DEV; }
        // set non-blocking flag
        status = fcntl( sockfd, F_SETFL, O_NONBLOCK );
        if(status == -1) { return  MQTT_RESP_ERR; }
        // prepare address & port number of the broker this client will connect
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_port   = htons(mctx->broker_port);
        if(connect(sockfd, (const struct sockaddr *)&serv_addr, sizeof(serv_addr)) == -1) {
            close(sockfd);
            return MQTT_RESP_ERR_CONN;
        } // connect to MQTT broker
    }
    else { // the given broker_host stores host name, not IP address, which requires DNS lookup first
        // TODO: test & refactor this part of code
        struct addrinfo  *dnlu_result = NULL; // result linked list of domain name lookup
        struct addrinfo  *idx         = NULL;
        // convert host name to IP address, set service argument to NULL
        status = getaddrinfo((const char *)&mctx->broker_host->data[0], NULL, NULL, &dnlu_result);
        if(status != 0) { return MQTT_RESP_ERR_CONN; }
        for(idx = dnlu_result; idx != NULL; idx = idx->ai_next)
        { // iterate over result address list generated by getaddrinfo() above
            sockfd = socket( idx->ai_family, idx->ai_socktype, idx->ai_protocol );
            if(sockfd == -1) { continue; }
            // set non-blocking flag
            status = fcntl( sockfd, F_SETFL, O_NONBLOCK );
            if(status == -1) { continue; }
            // directly set the port number
            struct sockaddr *ai_addr_p = idx->ai_addr;
            switch(ai_addr_p->sa_family) { // should ai_addr->sa_family always be the same as idx->ai_family ?
                case AF_INET6:
                    ((struct sockaddr_in6 *)ai_addr_p)->sin6_port = htons(mctx->broker_port);
                    break;
                case AF_INET:
                default:
                    ((struct sockaddr_in *)ai_addr_p)->sin_port = htons(mctx->broker_port);
                    break;
            } // end of switch-case statement
            status = connect(sockfd, (const struct sockaddr *)idx->ai_addr, idx->ai_addrlen);
            if(status == -1) { // connection failure, try next IP address (if exists)
                close(sockfd);
                continue;
            }
            break; // break as soon as connection success happens
        } // end of for-loop statement
        freeaddrinfo(dnlu_result) ; // free the list generated from getaddrinfo() above
        if(idx == NULL) { return MQTT_RESP_ERR_CONN ; }
    } // end of host name check

    mctx->ext_sysobjs[0] = (void *) sockfd;
    return  MQTT_RESP_OK ;
} // end of mqttSysNetconnStart



mqttRespStatus  mqttSysNetconnStop( mqttCtx_t *mctx )
{
    if(mctx == NULL) { return MQTT_RESP_ERRARGS; }
    int sockfd = (int) mctx->ext_sysobjs[0] ;
    mctx->ext_sysobjs[0] = NULL;
    if(sockfd <= 0){ return MQTT_RESP_ERR; }
    if(close(sockfd) != 0){ return MQTT_RESP_ERR_CONN; }
    return  MQTT_RESP_OK ;
} // end of mqttSysNetconnStop



int  mqttSysPktRead( mqttCtx_t *mctx, byte *buf, word32 buf_len )
{
    if((mctx == NULL) || (buf == NULL) || (buf_len == 0)) {
        return MQTT_RESP_ERRARGS;
    }
    size_t  rd_len_total = 0; // total length of copied data
    int     sockfd  = (int) mctx->ext_sysobjs[0];
    int     status  = 0;
    status = recv( sockfd, (void *)buf, buf_len, MSG_DONTWAIT );
    if(status == -1){ // TODO: find better way to implement this
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return rd_len_total; 
        } 
        else {
            return MQTT_RESP_TIMEOUT; 
        }
    }
    return rd_len_total;
} // end of mqttSysPktRead




int  mqttSysPktWrite( mqttCtx_t *mctx, byte *buf, word32 buf_len )
{
    if((mctx == NULL) || (buf == NULL) || (buf_len == 0)) {
        return MQTT_RESP_ERRARGS ;
    }
    size_t  wr_len_total = 0; // total length of written data
    int  sockfd  = (int) mctx->ext_sysobjs[0];
    int  status  = 0;
    // here we enable non-blocking write operation
    status = send( sockfd, (const void *)buf, buf_len, MSG_DONTWAIT );
    if(status == -1){
        if (errno == EAGAIN || errno == EWOULDBLOCK) {
            return wr_len_total; 
        } 
        else {
            return MQTT_RESP_ERR_TRANSMIT; 
        }
    }
    wr_len_total = (size_t)status;
    return  wr_len_total;
} // end of mqttSysPktWrite





mqttRespStatus  mqttSysThreadCreate( const char* name, mqttSysThreFn thread_fn, void* const arg,
                                     size_t stack_size,  uint32_t prio, uint8_t isPrivileged,
                                     mqttSysThre_t *out_thread_ptr  )
{
    pthread_attr_t  attr;
    struct sched_param  param;
    int status = 0;
    if((name == NULL) || (thread_fn == NULL)) {
        return MQTT_RESP_ERRARGS;
    }

    status = pthread_attr_init(&attr);
    if(status != 0){ return MQTT_RESP_ERR; }
    status = pthread_setname_np(&attr, name);
    if(status != 0){ return MQTT_RESP_ERR; }
    if(stack_size > 0) {
        status = pthread_attr_setstacksize(&attr, stack_size);
        if(status != 0){ return MQTT_RESP_ERRMEM; }
    }
    param.sched_priority = prio;
    status = pthread_attr_setschedparam(&attr, (const struct sched_param *)&param);
    if(status != 0){ return MQTT_RESP_ERR; }
    status = pthread_create((pthread_t *)out_thread_ptr, (const pthread_attr_t *)&attr,
                              thread_fn, arg );
    pthread_attr_destroy(&attr);
    (void)isPrivileged;
    return (status != 0) ? MQTT_RESP_ERR: MQTT_RESP_OK;
} // end of mqttSysThreadCreate



mqttRespStatus  mqttSysThreadDelete( mqttSysThre_t *thre_in )
{   // dummy function
    return MQTT_RESP_OK;
} // end of mqttSysThreadDelete



mqttRespStatus  mqttSysThreadWaitUntilExit( mqttSysThre_t *thre_in, void **return_p )
{
    void *retval = NULL;
    int   status = 0;
    if(thre_in == NULL) { return MQTT_RESP_ERRARGS; }
    status = pthread_join(*thre_in, &retval );
    if(return_p != NULL) {
        *return_p = retval;
    }
    return (status != 0) ? MQTT_RESP_ERR: MQTT_RESP_OK;
} // end of mqttSysThreadWaitUntilExit



word32  mqttSysRNG( word32 maxnum )
{ // TODO: find better way to implement this part
    const size_t buf_len = 4;
    FILE     *fp         = NULL;
    word32   *read_int_p = NULL ;
    byte      buf[buf_len];

    fp = fopen("/dev/urandom", "rb");
    if(fp == NULL) {
        fp = fopen("/dev/random", "rb");
    }
    if(fp == NULL) { return 0; }
    // disable buffering
    if(setvbuf(fp, NULL, _IONBF, 0) != 0) {
        fclose(fp);
        return 0;
    }
    fread( &buf[0], 1, buf_len, fp );
    fclose(fp);
    read_int_p = (word32 *)&buf[0];
    return  ((*read_int_p) % (maxnum + 1));
} // end of mqttUtilPRNG



